# üß© 007: Managing Unique Items with Sets

Imagine you have a list of guest RSVPs, but some people have replied more than once. How do you get a final, unique list of attendees? Or how do you quickly check if a specific person has RSVP'd? For these jobs, you need a **set**.

A set is an **unordered** collection of **unique** items. Think of it as a bag of things, rather than an ordered list. You can put things in, take things out, but there's no concept of "first" or "last", and duplicates are automatically rejected.

---

## ü§î What Is a Set?

A set is a collection where every element is unique and the order of elements does not matter. You can create a set using curly braces `{}` or the `set()` constructor.

```python
# Creating a set with curly braces
fruits = {"apple", "banana", "cherry"}
print(fruits) # The order of output is not guaranteed

# Creating a set from a list (duplicates are automatically removed)
numbers_list = [1, 2, 2, 3, 4, 3]
unique_numbers = set(numbers_list)
print(unique_numbers) # {1, 2, 3, 4}
```

**‚ö†Ô∏è Important:** To create an *empty set*, you **must** use `set()`. Using `{}` will create an empty dictionary, not an empty set!

```python
empty_set = set()
empty_dict = {}
```

## ‚ú® Why Are Sets So Important?

Sets are the perfect tool for specific jobs where lists would be inefficient.

*   **Deduplication:** They provide the quickest and cleanest way to get the unique items from any other collection.
*   **Ultra-Fast Membership Testing:** Checking if an item exists in a set (`item in my_set`) is incredibly fast, much faster than checking for an item in a list, especially for large collections. This is their main performance advantage.
*   **Mathematical Operations:** Sets allow you to perform powerful mathematical operations like union, intersection, and difference with a simple, readable syntax.

---

## üöÄ How Do I Work with Sets?

Let's see how to use the unique features of sets.

### 1. Adding and Removing Items

Even though the elements of a set must be immutable, the set itself is mutable.

```python
# Let's track a set of users who are online
online_users = {"Alice", "Bob"}
print(f"Online: {online_users}")

# A new user comes online
online_users.add("Charlie")
print(f"Charlie logged in: {online_users}")

# A user logs out
online_users.remove("Bob")
print(f"Bob logged out: {online_users}")

# Use .discard() if you're not sure the item is in the set
# .remove() would cause an error if "David" isn't there
online_users.discard("David")
```

### 2. The Power of Set Operations

This is where sets truly shine. Let's say we have two groups of friends.

```python
group_a = {"Alice", "Bob", "Charlie"}
group_b = {"Charlie", "David", "Eve"}
```

*   **Union (`|`):** All friends from both groups, with no duplicates.
    ```python
    all_friends = group_a | group_b
    print(f"All friends: {all_friends}")
    # {'Alice', 'Bob', 'Charlie', 'David', 'Eve'}
    ```

*   **Intersection (`&`):** Friends who are in *both* groups.
    ```python
    mutual_friends = group_a & group_b
    print(f"Mutual friends: {mutual_friends}")
    # {'Charlie'}
    ```

*   **Difference (`-`):** Friends who are in the first group but *not* the second.
    ```python
    only_in_a = group_a - group_b
    print(f"Only in Group A: {only_in_a}")
    # {'Alice', 'Bob'}
    ```

*   **Symmetric Difference (`^`):** Friends who are in one group or the other, but *not both*.
    ```python
    exclusive_friends = group_a ^ group_b
    print(f"Exclusive friends: {exclusive_friends}")
    # {'Alice', 'Bob', 'David', 'Eve'}
    ```

### 3. What You CAN'T Do

Because sets are unordered, you cannot access items by index.

```python
# online_users[0] # ‚ùå TypeError: 'set' object is not subscriptable
```

If you need to access items by their position, you should use a list or a tuple. You can always convert a set to a list if you need to:

```python
sorted_users = sorted(list(online_users))
print(f"Sorted users: {sorted_users}")
```

Use sets whenever you need to manage a collection of unique items or perform membership tests and mathematical set logic. They are a powerful and efficient tool in the Python language.
